# -*- coding: utf-8 -*-
#
# band.py
#
# This file creates Band class reading .bands file generated by Alamode.
#
# Copyright (c) 2022 Masato Ohnishi
#
# This file is distributed under the terms of the MIT license.
# Please see the file 'LICENCE.txt' in the root directory
# or http://opensource.org/licenses/mit-license.php for information.
#
import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
import matplotlib.cm as cm
from mpl_toolkits.axes_grid1.inset_locator import inset_axes

from auto_kappa.plot.initialize import get_customized_cmap, set_legend, set_axis

import logging
logger = logging.getLogger(__name__)

class Band:
    def __init__(self, filename=None):
        """ Class to read and plot band structure data from .bands file.
        
        How to use
        ------------
        >>> from auto_kappa.plot import set_matplot, set_legend
        >>> from auto_kappa.plot.initialize import prepare_two_axes
        >>> from auto_kappa.io.band import Band
        >>> from auto_kappa.io.dos import Dos
        >>> import matplotlib.pyplot as plt
        
        >>> fontsize = 7
        >>> fig_width = 3.0; aspect = 0.6; lw = 0.5
        >>> color = 'blue'
        >>> formula = "Si"
        >>> figname = 'fig_bandos.png'
        
        >>> set_matplot(fontsize=fontsize)
        >>> fig = plt.figure(figsize=(fig_width, aspect*fig_width))
        >>> ax_band, ax_dos = prepare_two_axes(ratio="2:1")
        >>> cmap = plt.get_cmap('tab10')
        
        >>> file_band = "./mp-149/harm/bandos/Si.bands"
        >>> band = Band("./mp-149/harm/bandos/Si.bands")
        >>> band.plot(ax_band, color=color, lw=lw, plot_G2G=True, label=formula)
        
        >>> file_dos = file_band.replace(".bands", ".dos")
        >>> dos = Dos(file_dos)
        >>> dos.plot(ax_dos, plot_pdos=True, show_legend=True,
        ...          color=color, lw=lw,
        ...          ylabel="DOS (a.u.)", xlabel=None)
        
        >>> fig.savefig(figname, dpi=600, bbox_inches='tight')
        
        Args
        ----
        unit : string
            unit of frequency
        
        nk : integer
            # of k points
        
        nbands : integer
            # of bands
        
        kpoints : array, float, shape=(nk)
            k-points
        
        frequencies : ndarray, float, shape=(nk, nbands)
            frequencies
        
        symmetry_labels : array, string, shape=(nsym)
            Labels for symmetry points
        
        symmetry_kpoints : array, float, shape=(nsym)
            k-points for symmetry points
        
        """
        self.band_type = 'normal'
        self.unit = "cm^1"
        self._kmax = None
        
        ### eigenvalues and vectors
        self.kpoints = None
        self.frequencies = None
        
        ### symmetry points
        self.symmetry_labels = None
        self.symmetry_kpoints = None
        if filename is not None:
            self.read_bfile(filename)
    
    @property
    def nk(self):
        if self.kpoints is None:
            return None
        return len(self.kpoints)
    @property
    def nbands(self):
        if self.frequencies is None:
            return None
        return self.frequencies.shape[1]

    @property
    def kmax(self):
        if self._kmax is None:
            self._kmax = self.kpoints[-1]
        return self._kmax
    
    def set_symmetry_points(self, bfile):
        self.symmetry_labels, self.symmetry_kpoints = get_symmetry_points_from_file(bfile)
    
    def set_eigen_values(self, bfile):
        """ Read band file crated by ALAMODE """
        out = get_eigen(bfile)
        if len(out) != 2:
            logger.error("\n Error: The band file is not valid.")
            return None
        self.kpoints = out[0]
        self.frequencies = out[1]
        
    def read_bfile(self, bfile):
        """Read band file
        """
        # self.set_nk_nbands(bfile)
        self.set_symmetry_points(bfile)
        self.set_eigen_values(bfile)
    
    def plot_bands(self, **args):
        msg = "\n Warning: plot_bands() will be deprecated. Use plot() method instead."
        logger.warning(msg)
        self.plot(**args)
    
    def _get_indices_of_1st_and_2nd_gamma(self):
        """Get indices of the first and second gamma points in kpoints and symmetry_kpoints.
        If there are no gamma points, return 0 and nk-1.
        
        Returns
        -------
        idx_init : int
            Index of the first gamma point.
        idx_end : int
            Index of the second gamma point.
        itick_init : int
            Index of the first gamma point in symmetry_kpoints.
        itick_end : int
            Index of the second gamma point in symmetry_kpoints.
        """
        gamma_kpoints = []
        itick_gammas = []
        for i, lab in enumerate(self.symmetry_labels):
            if lab.startswith('G'):
                gamma_kpoints.append(self.symmetry_kpoints[i])
                itick_gammas.append(i)
        if len(gamma_kpoints) >= 2:
            idx_init = np.argmin(abs(self.kpoints - gamma_kpoints[0]))
            idx_end = np.argmin(abs(self.kpoints - gamma_kpoints[1]))
            return ((idx_init, idx_end), (itick_gammas[0], itick_gammas[1]))
        else:
            return ((0, self.nk - 1), (0, len(self.symmetry_labels) - 1))
    
    def plot(self, ax, color=None, lw=0.3, linestyle='-', plot_G2G=False,
             ylabel="Frequency (${\\rm cm^{-1}}$)", 
             label=None, show_legend=True, set_xticks=True):
        """ Plot band structure
        
        Args
        ----
        ax : matplotlib.axes.Axes
            Axes to plot
        
        color : string, optional
            Color of the lines. Default is None, which means blue for normal band and customized 
            colormap for scph band. If temperature and color are both specified for scph band, 
            the given color is used.
        
        lw : float, optional
            Line width. Default is 0.3.
        
        linestyle : string, optional
            Line style. Default is '-'. 
        
        ylabel : string, optional
            Label for y-axis. Default is "Frequency (${\\rm cm^{-1}}$)"
            
        label : string, optional
            Label for the first band. Default is None, which means no label.
        
        show_label : bool, optional
            Whether to show the legend if it exists. Default is True.
        
        """
        from auto_kappa.plot.bandos import set_xticks_labels
        
        col = color if color is not None else 'blue'
        
        ## For partial plot (between the first and second gamma points)
        idx_init = 0
        idx_end = self.nk - 1
        itick_init = 0
        itick_end = len(self.symmetry_labels) - 1
        if plot_G2G:
            (idx_init, idx_end), (itick_init, itick_end) = self._get_indices_of_1st_and_2nd_gamma()
        
        ## Plot each band
        for ib in range(self.nbands):
            lab = label if ib == 0 else None
            x = self.kpoints[idx_init:idx_end+1]
            y = self.frequencies[idx_init:idx_end+1, ib]
            ax.plot(x, y, color=col, lw=lw, linestyle=linestyle, label=lab)
        
        ## set x-axis labels
        if set_xticks:
            
            _symmetry_labels = self.symmetry_labels[itick_init:itick_end+1]
            if plot_G2G:
                _symmetry_labels[-1] = 'GAMMA'
            
            set_xticks_labels(ax, self.symmetry_kpoints[itick_end], 
                              self.symmetry_kpoints[itick_init:itick_end+1], 
                              _symmetry_labels)
        
        ax.set_ylabel(ylabel)
        set_axis(ax)
        
        if show_legend:
            if ax.get_legend() is not None:
                set_legend(ax, fs=6, loc='lower left', loc2=(0.0, 1.0))

    def plot_with_weighted_colors(
        self, ax, weights, plot_G2G=False,
        lw=0.8, cmap='viridis', norm=None,
        set_xticks=True, colorbar=True, cbar_location='right',
        ylabel="Frequency (${\\rm cm^{-1}}$)",
        clabel=None):
        """ Plot band structure with color based on weights 
        """
        from auto_kappa.plot.bandos import set_xticks_labels
        
        cmin_weight = weights.min()
        cmax_weight = weights.max()

        if norm is None:
            cmin = cmin_weight
            cmax = cmax_weight
            norm = plt.Normalize(cmin, cmax)
        else:
            cmin = norm.vmin
            cmax = norm.vmax
        
        ## Partial plot
        ## if plot_G2G is True, plot only between the first and second gamma points
        ## For partial plot (between the first and second gamma points)
        idx_init = 0
        idx_end = self.nk - 1
        itick_init = 0
        itick_end = len(self.symmetry_labels) - 1
        if plot_G2G:
            (idx_init, idx_end), (itick_init, itick_end) = self._get_indices_of_1st_and_2nd_gamma()
        
        ## Plot each band with color based on weights
        x = self.kpoints[idx_init:idx_end+1]
        for ib in range(self.nbands):
            
            y = self.frequencies[idx_init:idx_end+1, ib]
            c = weights[idx_init:idx_end+1, ib]
            
            points = np.array([x, y]).T.reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)
            
            lc = LineCollection(segments, cmap=cmap, norm=norm)
            lc.set_array(c[:-1])
            lc.set_linewidth(lw)
            ax.add_collection(lc)
        
        ### ver.1
        ax.autoscale()
        #
        # ### ver.2
        # y0 = self.frequencies.min()
        # y1 = self.frequencies.max()
        # ymin = y0 - 0.05 * (y1 - y0)
        # ymax = y1 + 0.05 * (y1 - y0)
        # ax.set_ylim(ymin, ymax)
        
        ax.axhline(0, color='grey', lw=lw*0.3, ls='-')
        
        if set_xticks:
            set_xticks_labels(ax, self.symmetry_kpoints[itick_end], 
                              self.symmetry_kpoints[itick_init:itick_end+1], 
                              self.symmetry_labels[itick_init:itick_end+1])
        
        ax.set_ylabel(ylabel)
        set_axis(ax)
        if ax.get_legend() is not None:
            set_legend(ax, fs=6, loc='lower left', loc2=(0.0, 1.0))
        
        if colorbar:
            dummy_lc = LineCollection([], cmap=cmap, norm=norm)
            dummy_lc.set_array(np.linspace(cmin, cmax, 100))
            cax, cbar = _add_colorbar(ax, dummy_lc, 
                                      cbar_location=cbar_location)
            set_axis(cax, yscale='linear')
            if cbar_location == 'right':
                cax.set_ylim([cmin_weight, cmax_weight])
            else:
                cax.set_xlim([cmin_weight, cmax_weight])
            cbar.set_label(clabel)

class SCPHBand(Band):
    def __init__(self, filename=None):
        super().__init__()
        self.band_type = 'scph'
        self.temperatures = None
        if filename is not None:
            self.read_bfile(filename)
    
    @property
    def kmax(self): # for SCPH
        if self._kmax is None:
            self._kmax = self.kpoints[0][-1]
        return self._kmax
    @property
    def nbands(self):
        if self.frequencies is None:
            return None
        return self.frequencies.shape[2]
    @property
    def ntemps(self):
        if self.temperatures is None:
            return None
        return len(self.temperatures)
    
    def set_eigen_values(self, bfile): # for SCPH
        """ Read band file crated by ALAMODE """
        out = get_eigen(bfile)
        if len(out) != 3:
            logger.error("\n Error: The band file is not valid.")
            return None
        self.temperatures = out[0]
        self.kpoints = out[1]
        self.frequencies = out[2]
        
    def plot(self, ax, color=None, lw=0.3, linestyle='-',
             ylabel="Frequency (${\\rm cm^{-1}}$)", 
             temperature=None, label=None, show_legend=True, set_xticks=True):
        """ Plot SCPH band structure. See Band.plot for details.
        """
        from auto_kappa.plot.bandos import set_xticks_labels
        
        cmap = get_customized_cmap(len(self.temperatures))
            
        for it, temp in enumerate(self.temperatures):
            
            if temperature is not None:
                if abs(temp - temperature) > 0.1:
                    continue
            
            for ib in range(self.nbands):
                if temperature is None:
                    ## Only the first and last branches are labeled
                    if ib == 0 and (it == 0 or it == len(self.temperatures) - 1 or temperature is not None):
                        lab = "%dK" % int(temp)
                    else:
                        lab = None
                    col = cmap(it)
                else:
                    lab = label if ib == 0 else None
                    col = color if color is not None else cmap(it)
                
                ax.plot(self.kpoints[it], self.frequencies[it][:, ib], 
                        c=col, linestyle=linestyle, lw=lw, label=lab)
            
        ## set x-axis
        if set_xticks:
            set_xticks_labels(ax, self.kmax, self.symmetry_kpoints, self.symmetry_labels)
        ax.set_ylabel(ylabel)
        set_axis(ax)
        
        if show_legend:
            set_legend(ax, fs=6, loc='lower left', loc2=(0.0, 1.0), ncol=2)


def _add_colorbar(ax, lc, cbar_location='right', height=None, width=None):
    """ Add colorbar to the given axes with LineCollection.
    
    Args
    ----
    ax : matplotlib.axes.Axes
        Axes to add colorbar.
        
    lc : matplotlib.collections.LineCollection
        LineCollection object to be used for colorbar.
    
    cbar_location : str, optional
        Location of the colorbar. Can be 'right' or 'top'.
    
    height : str, optional
        Height of the colorbar. Default is None, which means "100%" for 'right
        
    width : str, optional
        Width of the colorbar. Default is None, which means "5%" for 'right
    
    """
    cbar_pad = 0.1
    if cbar_location == 'right':
        # location = 'right'
        bbox_to_anchor = (0.1, 0.0, 1, 1)
        height = "100%" if height is None else height
        width = "5%" if width is None else width
        orientation = "vertical"
    
    elif 'upper' in cbar_location:
        bbox_to_anchor = (0.0, 0.10, 1, 1)
        height = "6%" if height is None else height
        width = "50%" if width is None else width
        orientation = "horizontal"
        
    else:
        logger.error("\n Error: cbar_location must be 'right' or 'top'.")
        return None, None
        
    cax = inset_axes(ax, width=width, height=height, loc=cbar_location,
                     borderpad=cbar_pad,
                     bbox_to_anchor=bbox_to_anchor,
                     bbox_transform=ax.transAxes)
    
    cbar = ax.figure.colorbar(lc, cax=cax, orientation=orientation)
    
    if 'upper' in cbar_location:
        cbar.ax.xaxis.set_ticks_position('top')
        cbar.ax.xaxis.set_label_position('top')
    
    cbar.ax.tick_params(labelsize=6)
    cbar.set_label("Weight", fontsize=6)
    set_axis(cax)
    return cax, cbar

def get_nk_nbands(bfile):
    """Get nk and nbands from band file
    Parameters
    ------------
    bfile : string
        band file name of ALAMODE
    
    Returns
    ----------
    nk, nband : integer
        # of k-points and bands
    """
    nline = sum(1 for line in open(bfile))
    nk = nline - 3
    ifs = open(bfile, "r")
    for i in range(4):
        line = ifs.readline()
    data = line.split()
    nbands = len(data) - 1
    return nk, nbands

def get_symmetry_points_from_file(bfile):
    """Read symmetry points from band file
    
    Returns
    ---------
    label : string
        label for symmetry points
    
    ksym : double
        \|k\| for symmetry points
    
    """
    ifs = open(bfile, "r")
    nline = sum(1 for line in open(bfile))
    lines = []
    lines.append(ifs.readline())
    lines.append(ifs.readline())
    return get_symmetry_points_from_string(lines)

def get_symmetry_points_from_string(lines):
    """Read symmetry points from band file
    
    Returns
    ---------
    label : string
        label for symmetry points
    
    ksym : double
        \|k\| for symmetry points
    
    """
    data1 = lines[0].split()
    data2 = lines[1].split()
    
    label_tmp = []
    kpoints = []
    for i in range(len(data1)-1):
        label_tmp.append(data1[1+i])
        kpoints.append(float(data2[1+i]))
    label = []
    nticks = len(label_tmp)
    for it in range(nticks):
        lab0 = label_tmp[it]
        lab = label_tmp[it]
        if it != 0 and it != nticks-1:
            if abs(kpoints[it] - kpoints[it+1]) < 1e-5:
                lab = "%s|%s" % (lab0, label_tmp[it+1])
            if abs(kpoints[it] - kpoints[it-1]) < 1e-5:
                lab = "%s|%s" % (label_tmp[it-1], lab0)

        ### ver.1
        #if "gamma" in lab.lower() or 'G' in lab:
        #    label.append("G")
        #else:
        #    label.append("%s"%(lab))
        #
        ### ver.2
        lab = lab.upper()
        label.append(lab)
    
    ### adjust
    lab_new = []
    knew = []
    lab_new.append(label[0])
    knew.append(kpoints[0])
    for ii in range(1,len(label)):
        if (abs(kpoints[ii] - kpoints[ii-1]) < 1e-5 and
                label[ii] == label[ii-1]):
            pass
        else:
            lab_new.append(label[ii])
            knew.append(kpoints[ii])
    return lab_new, knew

def get_eigen(filename):
    """ Get kpoints and frequencies """
    
    ### check whether normal band or scph bands
    lines = open(filename, 'r').readlines()

    if "temperature" in lines[2].lower():
        return get_scph_bands(filename)
    else:
        return get_normal_bands(filename)

def get_normal_bands(filename):
    """ Read .bands file """
    dump = np.genfromtxt(filename)
    kpoints = dump[:,0]
    frequencies = dump[:,1:]
    return [kpoints, frequencies]

def get_scph_bands(filename, logfile=None, tol=0.1, verbose=True):
    """ Read .scph_bands file and return array of dictionary for each 
    temperature.
    """
    dump = np.genfromtxt(filename)
    ndat = len(dump[:,0])

    ### get list of temperatures
    temperatures = []
    temperatures.append(dump[0,0])
    for i in range(1, ndat):
        T0 = dump[i-1,0]
        T1 = dump[i,0]
        if abs(T1 - T0) > tol:
            temperatures.append(T1)
    temperatures = np.asarray(temperatures)
    
    ###
    kpoints_list = []
    frequencies_list = []
    for temp in temperatures:
        idx = np.where(abs(dump[:,0] - temp) < tol)[0]
        kpoints_list.append(dump[idx,1])
        frequencies_list.append(dump[idx,2:])
    kpoints = np.asarray(kpoints_list)
    frequencies = np.asarray(frequencies_list)
    
    ## Delete data at unavailable temperatures
    from auto_kappa.calculators.scph import get_availabilities
    availabilities = None
    if logfile is None:
        logfile = os.path.dirname(filename) + "/scph.log"
    if os.path.exists(logfile):
        availabilities = get_availabilities(logfile)
        for temp, flag in availabilities.items():
            if flag == False and verbose:
                logger.info(f" Not converged at {temp}K.")
    
    ## Delete unavailable data
    if availabilities is not None:
        idx_na = []
        for it, temp in enumerate(temperatures):
            if availabilities[int(temp)] == False:
                idx_na.append(it)
        temperatures = np.delete(temperatures, idx_na)
        kpoints = [np.delete(ks, idx_na, axis=0) for ks in kpoints]
        frequencies = [np.delete(fs, idx_na, axis=0) for fs in frequencies]
        kpoints = np.asarray(kpoints)
        frequencies = np.asarray(frequencies)
    
    return [temperatures, kpoints, frequencies]
