#
# fcs.py
#
# This file helps to parse the force constant data from XML files generated by Alamode.
#
# Functions in this script are partially followed by the discussion in
# https://github.com/ttadano/alamode/discussions/192
#
# Copyright (c) 2025 Masato Ohnishi
#
# This file is distributed under the terms of the MIT license.
# Please see the file 'LICENCE.txt' in the root directory
# or http://opensource.org/licenses/mit-license.php for information.
#
import sys
import numpy as np
from lxml import etree
from itertools import product
from ase.units import Rydberg, Bohr
import ase
import matplotlib.pyplot as plt

from auto_kappa.plot import set_axis, set_legend

import logging
logger = logging.getLogger(__name__)

def _make_symbol_pair_index(symbol_lists):
    """ Create a mapping from symbol pairs to unique indices.
    For example, ('Si, O') and ('O', 'Si') will map to the same index.
    """
    if len(symbol_lists) == 2:
        combinations = [(el1, el2) for el1 in symbol_lists[0] for el2 in symbol_lists[1]]
    elif len(symbol_lists) == 3:
        combinations = [(el1, el2, el3) 
                        for el1 in symbol_lists[0] 
                        for el2 in symbol_lists[1] 
                        for el3 in symbol_lists[2]]
    elif len(symbol_lists) == 4:
        combinations = [(el1, el2, el3, el4) 
                        for el1 in symbol_lists[0] 
                        for el2 in symbol_lists[1] 
                        for el3 in symbol_lists[2] 
                        for el4 in symbol_lists[3]]
    else:
        msg = "\n Only 2, 3, or 4 symbol lists are supported."
        logger.error(msg)
        sys.exit()
    
    index_map = {}
    next_index = 0
    for combo in combinations:
        key = tuple(sorted(combo))
        if key not in index_map:
            index_map[key] = next_index
            next_index += 1
    
    return index_map
    
class FCSxml():
    def __init__(self, filename: str=None):
        
        self._root = None
        self._natom_super = None
        self._natom_prim = None
        self._ntrans = None
        self._force_constants = {2: None, 3: None, 4: None}
        self._map_p2s = None
        #
        self._cell = None
        self._supercell = None
        self._prim_positions = None
        self._distances = None
        
        if filename is not None:
            self._file_xml = filename
            self.parse_xml()
    
    @property
    def file_xml(self):
        return self._file_xml
    
    def parse_xml(self):
        try:
            # Attempt to parse the XML file directly with lxml
            tree = etree.parse(self.file_xml)
        except etree.XMLSyntaxError:
            # If a parsing error occurs with lxml,
            # attempt to repair by re-reading the file with the 'recover' parser
            repair_parser = etree.XMLParser(recover=True)
            tree = etree.parse(self.file_xml, parser=repair_parser)
        self._root = tree.getroot()
    
    @property
    def natom_super(self):
        if self._natom_super is None:
            self._natom_super = int(self._root.find('Structure/NumberOfAtoms').text)
        return self._natom_super
    @property
    def natom_prim(self):
        if self._natom_prim is None:
            self._natom_prim = self.natom_super // self.ntrans
        return self._natom_prim
    @property
    def ntrans(self):
        if self._ntrans is None:
            self._ntrans = int(self._root.find('Symmetry/NumberOfTranslations').text)
        return self._ntrans
    
    @property
    def cell(self):
        if self._cell is None:
            self._cell = self.get_cell()
        return self._cell
    
    def get_cell(self):
        lat_elements = self._root.find('Structure/LatticeVector')
        if lat_elements is None:
            return None
        a1 = lat_elements.find('a1').text.split()
        a2 = lat_elements.find('a2').text.split()
        a3 = lat_elements.find('a3').text.split()
        a1 = np.array([float(x) * Bohr for x in a1], dtype=float) # Convert to Angstrom
        a2 = np.array([float(x) * Bohr for x in a2], dtype=float)
        a3 = np.array([float(x) * Bohr for x in a3], dtype=float)
        cell = np.array([a1, a2, a3], dtype=float)
        return cell
    
    def get_positions_symbols(self):
        pos_elements = self._root.find('Structure/Position')
        positions = np.zeros((self.natom_super, 3), dtype=float)
        symbols = []
        for elems in pos_elements:
            index = int(elems.get('index'))
            positions[index-1, :] = np.array([float(x) for x in elems.text.split()], dtype=float)
            symbols.append(elems.get('element'))
        return positions, symbols
    
    @property
    def supercell(self):
        if self._supercell is None:
            self._supercell = self.get_supercell()
        return self._supercell
    
    def get_supercell(self):
        positions, symbols = self.get_positions_symbols()
        supercell = ase.Atoms(
            scaled_positions=positions,
            symbols=symbols,
            cell=self.get_cell(),
            pbc=True)
        return supercell
    
    @property
    def fc2(self):
        if self._force_constants[2] is None:
            self._force_constants[2] = self.get_fc2()
        return self._force_constants[2]
    
    def get_fc2(self):
        fc2_compact = np.zeros((self.natom_prim, self.natom_super, 3, 3), dtype=float)
        fc2_elements = self._root.findall('ForceConstants/HARMONIC/FC2')
        if not fc2_elements:
            return None
        for elems in fc2_elements:
            atom1, xyz1 = [int(t)-1 for t in elems.get('pair1').split()]
            atom2, xyz2, icell2 = [int(t)-1 for t in elems.get('pair2').split()]
            fcsval = float(elems.text)
            fc2_compact[atom1, atom2, xyz1, xyz2] += fcsval
        fc2_compact *= Rydberg / (Bohr**2) # Convert from Ry/Bohr^2 to eV/Ang^2
        return fc2_compact

    @property
    def fc3(self):
        if self._force_constants[3] is None:
            self._force_constants[3] = self.get_fc3()
        return self._force_constants[3]
    
    def get_fc3(self):
        fc3_compact = np.zeros((self.natom_prim, self.natom_super, self.natom_super, 3, 3, 3), dtype=float)
        fc3_elements = self._root.findall('ForceConstants/ANHARM3/FC3')
        if not fc3_elements:
            return None
        for elems in fc3_elements:
            atom1, xyz1 = [int(t)-1 for t in elems.get('pair1').split()]
            atom2, xyz2, icell2 = [int(t)-1 for t in elems.get('pair2').split()]
            atom3, xyz3, icell3 = [int(t)-1 for t in elems.get('pair3').split()]
            fcsval = float(elems.text)
            fc3_compact[atom1, atom2, atom3, xyz1, xyz2, xyz3] += fcsval
        fc3_compact *= Rydberg / (Bohr**3) # Convert from Ry/Bohr^3 to eV/Ang^3
        return fc3_compact
    
    @property
    def fc4(self):
        if self._force_constants[4] is None:
            self._force_constants[4] = self.get_fc4()
        return self._force_constants[4]
    
    def get_fc4(self):
        fc4_compact = np.zeros((self.natom_prim, self.natom_super, self.natom_super, self.natom_super, 3, 3, 3, 3), dtype=float)
        fc4_elements = self._root.findall('ForceConstants/ANHARM4/FC4')
        if not fc4_elements:
            return None
        for elems in fc4_elements:
            atom1, xyz1 = [int(t)-1 for t in elems.get('pair1').split()]
            atom2, xyz2, icell2 = [int(t)-1 for t in elems.get('pair2').split()]
            atom3, xyz3, icell3 = [int(t)-1 for t in elems.get('pair3').split()]
            atom4, xyz4, icell4 = [int(t)-1 for t in elems.get('pair4').split()]
            fcsval = float(elems.text)
            fc4_compact[atom1, atom2, atom3, atom4, xyz1, xyz2, xyz3, xyz4] += fcsval
        fc4_compact *= Rydberg / (Bohr**4) # Convert from Ry/Bohr^4 to eV/Ang^4
        return fc4_compact
    
    @property
    def map_p2s(self):
        if self._map_p2s is None:
            self._map_p2s = self.get_map_p2s()
        return self._map_p2s
    
    def get_map_p2s(self):
        ## parse mapping table
        map_p2s = np.zeros((self.ntrans, self.natom_prim), dtype=int)
        for elems in self._root.findall('Symmetry/Translations/map'):
            itran = int(elems.get('tran')) - 1
            iatom = int(elems.get('atom')) - 1
            map_p2s[itran, iatom] = int(elems.text) - 1
        return map_p2s
    
    @property
    def primitive_positions(self):
        if self._prim_positions is None:
            indices = self.map_p2s[0, :]
            self._prim_positions = self.supercell.get_positions()[indices, :]
            # symbols = [self.supercell.get_symbols()[i] for i in indices]
        return self._prim_positions
    
    @property
    def distances(self):
        if not hasattr(self, '_distances'):
            self._distances = None
        if self._distances is None:
            self._distances = self.get_distances()
        return self._distances
    
    def get_distances(self):
        natom_prim = self.natom_prim
        natom_super = self.natom_super
        self._distances = np.zeros((natom_prim, natom_super), dtype=float)
        D, D_len = ase.geometry.get_distances(
            self.primitive_positions, self.supercell.get_positions(), 
            cell=self.supercell.cell, pbc=True)
        self._distances = D_len
        return D_len
        
    def print_fc2_phonopy(self):
        natom_prim, natom_super = self.fc2.shape[:2]
        print("{:5d} {:5d}".format(natom_prim, natom_super))
        for i in range(natom_prim):
            for j in range(natom_super):
                print("{:5d} {:5d}".format(self.map_p2s[0,i]+1, j+1))
                for k in range(3):
                    for l in range(3):
                        print("{:20.15f}".format(self.fc2[i, j, k, l]), end='')
                    print('')
    
    def print_fc3_phonopy(self):
        msg = "\n The print_fc3_phonopy method is not implemented yet."
        logger.warning(msg)
        return None
    
    def print_fc4_phonopy(self):
        msg = "\n The print_fc4_phonopy method is not implemented yet."
        logger.warning(msg)
        return None
    
    def plot_fc2(self, ax, color=None, title=None, show_legend=True,
                 xlabel='Distance (${\\rm \\AA}$)', 
                 ylabel='Harmonic FC (${\\rm eV/\\AA^2}$)',
                 lw=0.3, ms=2.3, xticks=None, mxticks=None):
        
        prim_indices = self.map_p2s[0, :]
        symbols_super = self.supercell.get_chemical_symbols()
        symbols_prim = [symbols_super[i] for i in prim_indices]
        symbol_list = list(dict.fromkeys(symbols_prim).keys())
        
        ## Create a mapping of symbol pairs to indices
        index_map = _make_symbol_pair_index([symbol_list, symbol_list])
        distances = self.supercell.get_all_distances(mic=True)
        
        ###
        fcs = self.fc2
        for iel1, el1 in enumerate(symbol_list):
            indices1_prim = [i for i, s in enumerate(symbols_prim) if s == el1] # indices in primitive cell
            for iel2, el2 in enumerate(symbol_list):
                indices2_sc = [i for i, s in enumerate(symbols_super) if s == el2] # indices in supercell
                
                pair_idx = index_map[tuple(sorted([el1, el2]))]
                label = f'{el1}-{el2}'
                
                xdat = np.zeros((len(indices1_prim), len(indices2_sc), 3, 3), dtype=float)
                ydat = np.zeros((len(indices1_prim), len(indices2_sc), 3, 3), dtype=float)
                for i1, iat1_prim in enumerate(indices1_prim):
                    iat1_sc = prim_indices[iat1_prim]
                    for i2, iat2_sc in enumerate(indices2_sc):
                        dmax = distances[iat1_sc, iat2_sc]
                        for j1 in range(3):
                            for j2 in range(3):
                                xdat[i1, i2, j1, j2] = dmax
                                ydat[i1, i2, j1, j2] = fcs[iat1_prim, iat2_sc, j1, j2]
                
                _plot_fcs(ax, xdat, ydat, pair_idx, color=color, label=label, lw=lw, ms=ms)
        
        _set_frame(ax, title, xlabel, ylabel, show_legend=show_legend)
        set_axis(ax, xticks=xticks, mxticks=mxticks)
    
    def plot_fc3(self, ax, color=None, title=None, show_legend=True,
                 xlabel='Distance (${\\rm \\AA}$)', 
                 ylabel='Cubic FC (${\\rm eV/\\AA^3}$)',
                 lw=0.3, ms=2.3, xticks=None, mxticks=None):
        
        prim_indices = self.map_p2s[0, :]
        symbols_super = self.supercell.get_chemical_symbols()
        symbols_prim = [symbols_super[i] for i in prim_indices]
        symbol_list = list(dict.fromkeys(symbols_prim).keys())
        
        ## Create a mapping of symbol pairs to indices
        index_map = _make_symbol_pair_index([symbol_list, symbol_list, symbol_list])
        distances = self.supercell.get_all_distances(mic=True)
        
        ##
        fcs = self.fc3
        for iel1, el1 in enumerate(symbol_list):
            indices1_prim = [i for i, s in enumerate(symbols_prim) if s == el1] # indices in primitive cell
            for iel2, el2 in enumerate(symbol_list):
                indices2_sc = [i for i, s in enumerate(symbols_super) if s == el2] # indices in supercell
                for iel3, el3 in enumerate(symbol_list):
                    indices3_sc = [i for i, s in enumerate(symbols_super) if s == el3] # indices in supercell

                    pair_idx = index_map[tuple(sorted([el1, el2, el3]))]
                    label = f'{el1}-{el2}-{el3}'
                    
                    xdat = np.zeros((len(indices1_prim), len(indices2_sc), len(indices3_sc), 3, 3, 3), dtype=float)
                    ydat = np.zeros((len(indices1_prim), len(indices2_sc), len(indices3_sc), 3, 3, 3), dtype=float)
                    for i1, iat1_prim in enumerate(indices1_prim):
                        iat1_sc = prim_indices[iat1_prim]
                        for i2, iat2_sc in enumerate(indices2_sc):
                            for i3, iat3_sc in enumerate(indices3_sc):
                                d12 = distances[iat1_sc, iat2_sc]
                                d13 = distances[iat1_sc, iat3_sc]
                                d23 = distances[iat2_sc, iat3_sc]
                                dmax = max(d12, d13, d23)
                                for j1, j2, j3 in product(range(3), repeat=3):
                                    xdat[i1, i2, i3, j1, j2, j3] = dmax
                                    ydat[i1, i2, i3, j1, j2, j3] = fcs[iat1_prim, iat2_sc, iat3_sc, j1, j2, j3]
                    
                    _plot_fcs(ax, xdat, ydat, pair_idx, color=color, label=label, lw=lw, ms=ms)
        
        _set_frame(ax, title, xlabel, ylabel, show_legend=show_legend)
        set_axis(ax, xticks=xticks, mxticks=mxticks)
    
    def plot_fc4(self, ax, color=None, title=None, show_legend=True,
                 xlabel='Distance (${\\rm \\AA}$)', 
                 ylabel='Quartic FC (${\\rm eV/\\AA^4}$)',
                 lw=0.3, ms=2.3, xticks=None, mxticks=None):
        
        prim_indices = self.map_p2s[0, :]
        symbols_super = self.supercell.get_chemical_symbols()
        symbols_prim = [symbols_super[i] for i in prim_indices]
        symbol_list = list(dict.fromkeys(symbols_prim).keys())
        
        ## Create a mapping of symbol pairs to indices
        index_map = _make_symbol_pair_index([symbol_list, symbol_list, symbol_list, symbol_list])
        
        distances = self.supercell.get_all_distances(mic=True)
        
        ##
        fcs = self.fc4
        for iel1, el1 in enumerate(symbol_list):
            indices1_prim = [i for i, s in enumerate(symbols_prim) if s == el1] # indices in primitive cell
            nat1 = len(indices1_prim)
            for iel2, el2 in enumerate(symbol_list):
                indices2_sc = [i for i, s in enumerate(symbols_super) if s == el2] # indices in supercell
                nat2 = len(indices2_sc)
                for iel3, el3 in enumerate(symbol_list):
                    indices3_sc = [i for i, s in enumerate(symbols_super) if s == el3] # indices in supercell
                    nat3 = len(indices3_sc)
                    for iel4, el4 in enumerate(symbol_list):
                        indices4_sc = [i for i, s in enumerate(symbols_super) if s == el4]
                        nat4 = len(indices4_sc)

                        pair_idx = index_map[tuple(sorted([el1, el2, el3, el4]))]
                        label = f'{el1}-{el2}-{el3}-{el4}'

                        xdat = np.zeros((nat1, nat2, nat3, nat4, 3, 3, 3, 3), dtype=float)
                        ydat = np.zeros((nat1, nat2, nat3, nat4, 3, 3, 3, 3), dtype=float)
                            
                        for i1, iat1_prim in enumerate(indices1_prim):
                            iat1_sc = prim_indices[iat1_prim]
                            for i2, iat2_sc in enumerate(indices2_sc):
                                for i3, iat3_sc in enumerate(indices3_sc):
                                    for i4, iat4_sc in enumerate(indices4_sc):
                                        d12 = distances[iat1_sc, iat2_sc]
                                        d13 = distances[iat1_sc, iat3_sc]
                                        d14 = distances[iat1_sc, iat4_sc]
                                        d23 = distances[iat2_sc, iat3_sc]
                                        d24 = distances[iat2_sc, iat4_sc]
                                        d34 = distances[iat3_sc, iat4_sc]
                                        dmax = max(d12, d13, d14, d23, d24, d34)
                                        for j1, j2, j3, j4 in product(range(3), repeat=4):
                                            xdat[i1, i2, i3, i4, j1, j2, j3, j4] = dmax
                                            ydat[i1, i2, i3, i4, j1, j2, j3, j4] = \
                                                fcs[iat1_prim, iat2_sc, iat3_sc, iat4_sc, j1, j2, j3, j4]
                        
                        _plot_fcs(ax, xdat, ydat, pair_idx, color=color, label=label, lw=lw, ms=ms)
        
        _set_frame(ax, title, xlabel, ylabel, show_legend=show_legend)
        set_axis(ax, xticks=xticks, mxticks=mxticks)

def _set_frame(ax, title, xlabel, ylabel, show_legend=True, fontsize=5):
    ax.set_title(title)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    set_axis(ax)
    if show_legend:
        set_legend(ax, loc='upper left', loc2=[1.0, 1.0], fs=fontsize, alpha=0.5)

def _plot_fcs(ax, xdat, ydat, pair_idx, color=None, label=None, tolerance=1e-7, lw=0.3, ms=2.3):
    cmap = plt.get_cmap('tab10')
    markers = ['o', '^', 's', 'D', 'v', 'x']
    xdat = xdat.flatten()
    ydat = ydat.flatten()
    # idx_nonzero = [i for i in range(len(xdat)) if abs(xdat[i]) > tolerance and abs(ydat[i]) > tolerance]
    idx_nonzero = [i for i in range(len(xdat)) if abs(ydat[i]) > tolerance]
    xdat = xdat[idx_nonzero]
    ydat = ydat[idx_nonzero]
    ax.axhline(0, linestyle='-', color='grey', lw=lw)
    if len(xdat) > 0 and len(ydat) > 0:
        ax.plot(xdat, ydat, marker=markers[pair_idx % len(markers)],
                ms=ms, linestyle='None', mew=lw,
                mec=color if color is not None else cmap(pair_idx % 10),
                mfc='none', label=label)
    ax.minorticks_on()
    
# def main():
#     fname_xml = sys.argv[1]
#     fcs = FCSxml(filename=fname_xml)
#         
#     fig, axes = make_figure(2, 1, aspect=1.3, fig_width=2.5)
#     fcs.plot_fc2(axes[0][0], ylabel='Harmonic FC (${\\rm eV/\\AA^2}$)', xlabel=None)
#     fcs.plot_fc3(axes[1][0], ylabel='Cubic FC (${\\rm eV/\\AA^3}$)', xlabel='Distance (${\\rm \\AA}$)')
#     fig.savefig('fig_fcs.png', dpi=600, bbox_inches='tight')
#
# if __name__ == '__main__':
#     main()
