# -*- coding: utf-8 -*-
#
# band.py
#
# This file creates Band class reading .bands file generated by Alamode.
#
# Copyright (c) 2022 Masato Ohnishi
#
# This file is distributed under the terms of the MIT license.
# Please see the file 'LICENCE.txt' in the root directory
# or http://opensource.org/licenses/mit-license.php for information.
#
import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
import matplotlib.cm as cm
from mpl_toolkits.axes_grid1.inset_locator import inset_axes

from auto_kappa.plot.initialize import get_customized_cmap, set_legend, set_axis

import logging
logger = logging.getLogger(__name__)

class Band():
    def __init__(self, filename=None):
        """Band
        Variables
        -----------
        unit : string
            unit of frequency
        nk : integer
            # of k points
        nbands : integer
            # of bands
        kpoints : array, float, shape=(nk)
            k-points
        frequencies : ndarray, float, shape=(nk, nbands)
            frequencies
        label : array, string, shape=(nsym)
            Labels for symmetry points
        ksym : array, float, shape=(nsym)
            k-points for symmetry points
        nsym : integer
            # of symmetry points
        """
        self.unit = "cm^1"
        self._ntemps = None
        self._nk = None
        self._nbands = None
        self._kmax = None
        
        ### eigenvalues and vectors
        self.band_type = None
        self.temperatures = None
        self.kpoints = None
        self.freqencies = None
        
        ### symmetry points
        self.label = None
        self.ksym = None
        if filename is not None:
            self.read_bfile(filename)
    
    @property
    def nk(self):
        return self._nk
    @property
    def nbands(self):
        return self._nbands
    @property
    def ntemps(self):
        return self._ntemps
    
    @property
    def kmax(self):
        if self._kmax is None:
            if self.band_type == 'normal':
                self._kmax = self.kpoints[-1]
            elif self.band_type == 'scph':
                self._kmax = self.kpoints[0][-1]
        return self._kmax
    
    def set_symmetry_points(self, bfile):
        self.label, self.ksym = get_symmetry_points_from_file(bfile)
    
    def set_eigen(self, bfile):
        """ Read band file crated by ALAMODE """
        out = get_eigen(bfile)
        if len(out) == 2:
            self.band_type = "normal"
            self.kpoints = out[0]
            self.frequencies = out[1]
            #
            self._nk = len(self.kpoints)
            self._nbands = len(self.frequencies[0])
        elif len(out) == 3:
            self.band_type = "scph"
            self.temperatures = out[0]
            self.kpoints = out[1]
            self.frequencies = out[2]
            #
            self._ntemps = len(self.temperatures)
            self._nk = len(self.kpoints[0])
            self._nbands = len(self.frequencies[0][0])
        else:
            logger.error("\n Error")
            return None
    
    def read_bfile(self, bfile):
        """Read band file
        """
        # self.set_nk_nbands(bfile)
        self.set_symmetry_points(bfile)
        self.set_eigen(bfile)
    
    def plot_bands(self, **args):
        msg = "\n Warning: plot_bands() will be deprecated. Use plot() method instead."
        logger.warning(msg)
        self.plot(**args)
        
    def plot(self, ax, color=None, lw=0.3, linestyle='-',
                   ylabel="Frequency (${\\rm cm^{-1}}$)", 
                   temperature=None, label=None, set_xticks=True):
        """ Plot band structure
        
        Args
        ----
        ax : matplotlib.axes.Axes
            Axes to plot
        
        color : string, optional
            Color of the lines. Default is None, which means blue for normal band and customized 
            colormap for scph band. If temperature and color are both specified for scph band, 
            the given color is used.
        
        lw : float, optional
            Line width. Default is 0.3.
        
        linestyle : string, optional
            Line style. Default is '-'. 
        
        ylabel : string, optional
            Label for y-axis. Default is "Frequency (${\\rm cm^{-1}}$)"
            
        temperature : float, optional
            Temperature to plot for scph band. Default is None, which means all temperatures are plotted.
            If specified, only the band structure at the given temperature is plotted.
        
        label : string, optional
            Label for the first band. Default is None, which means no label.
        
        show_label : bool, optional
            Whether to show the legend. Default is False.
        
        """
        from auto_kappa.plot.bandos import set_xticks_labels
        
        if self.band_type == 'scph':
            cmap = get_customized_cmap(len(self.temperatures))
        else:
            col = color if color is not None else 'blue'
            
        if self.band_type == "normal":
            for ib in range(self.nbands):
                lab = label if ib == 0 else None
                ax.plot(self.kpoints, self.frequencies[:, ib], color=col,
                        lw=lw, linestyle=linestyle, label=lab)
        
        elif self.band_type == "scph":
            for it, temp in enumerate(self.temperatures):
                
                if temperature is not None:
                    if abs(temp - temperature) > 0.1:
                        continue
                
                for ib in range(self.nbands):
                    if temperature is None:
                        if ib == 0 and (it == 0 or it == len(self.temperatures) - 1 or temperature is not None):
                            lab = "%dK" % int(temp)
                        else:
                            lab = None
                        col = cmap(it)
                    else:
                        lab = label if ib == 0 else None
                        col = color if color is not None else cmap(it)
                    ax.plot(self.kpoints[it], self.frequencies[it][:, ib], 
                            c=col, linestyle=linestyle, lw=lw, label=lab)
        
        ## set x-axis
        if set_xticks:
            set_xticks_labels(ax, self.kmax, self.ksym, self.label)
        ax.set_ylabel(ylabel)
        set_axis(ax)
        
        if ax.get_legend() is not None:
            set_legend(ax, fs=7, loc='lower left', loc2=(0.0, 1.03))
    
    def plot_with_weighted_colors(
        self, ax, weights, lw=0.8, cmap='viridis', norm=None,
        set_xticks=True, colorbar=True,
        ylabel="Frequency (${\\rm cm^{-1}}$)",
        clabel=None):
        """ Plot band structure with color based on weights 
        """
        from auto_kappa.plot.bandos import set_xticks_labels
        
        if self.band_type == 'scph':
            msg = "\n Error: scph band is not supported yet."
            logger.error(msg)
            return None
        
        cmin_weight = weights.min()
        cmax_weight = weights.max()

        if norm is None:
            cmin = cmin_weight
            cmax = cmax_weight
            norm = plt.Normalize(cmin, cmax)
        else:
            cmin = norm.vmin
            cmax = norm.vmax
        
        x = self.kpoints
        
        for ib in range(self.nbands):
            
            y = self.frequencies[:, ib]
            c = weights[:, ib]
            
            ##
            points = np.array([x, y]).T.reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)
            
            lc = LineCollection(segments, cmap=cmap, norm=norm)
            lc.set_array(c[:-1])
            lc.set_linewidth(lw)
            ax.add_collection(lc)
        
        # ax.autoscale()
        y0 = self.frequencies.min()
        y1 = self.frequencies.max()
        ymin = y0 - 0.05 * (y1 - y0)
        ymax = y1 + 0.05 * (y1 - y0)
        ax.set_ylim(ymin, ymax)
        
        ax.axhline(0, color='grey', lw=lw*0.3, ls='-')
        
        if set_xticks:
            set_xticks_labels(ax, self.kmax, self.ksym, self.label)
        
        ax.set_ylabel(ylabel)
        set_axis(ax)
        if ax.get_legend() is not None:
            set_legend(ax, fs=7, loc='lower left', loc2=(0.0, 1.03))
        
        if colorbar:
            dummy_lc = LineCollection([], cmap=cmap, norm=norm)
            dummy_lc.set_array(np.linspace(cmin, cmax, 100))
            cax, cbar = _add_colorbar(ax, dummy_lc, cbar_location='right')
            set_axis(cax, yscale='linear')
            cax.set_ylim([cmin_weight, cmax_weight])
            cbar.set_label(clabel)

def _add_colorbar(ax, lc, cbar_location='right', height=None, width=None):
    """ Add colorbar to the given axes with LineCollection.
    
    Args
    ----
    ax : matplotlib.axes.Axes
        Axes to add colorbar.
        
    lc : matplotlib.collections.LineCollection
        LineCollection object to be used for colorbar.
    
    cbar_location : str, optional
        Location of the colorbar. Can be 'right' or 'top'.
    
    height : str, optional
        Height of the colorbar. Default is None, which means "100%" for 'right
        
    width : str, optional
        Width of the colorbar. Default is None, which means "5%" for 'right
    
    """
    cbar_pad = 0.1
    if cbar_location == 'right':
        location = 'right'
        bbox_to_anchor = (0.1, 0.0, 1, 1)
        height = "100%" if height is None else height
        width = "5%" if width is None else width
        orientation = "vertical"
    
    elif cbar_location == 'top':
        location = 'upper right'
        bbox_to_anchor = (0.0, 0.15, 1, 1)
        height = "10%" if height is None else height
        width = "50%" if width is None else width
        orientation = "horizontal"
    
    else:
        logger.error("\n Error: cbar_location must be 'right' or 'top'.")
        return None, None
        
    cax = inset_axes(ax, width=width, height=height, loc=location,
                     borderpad=cbar_pad,
                     bbox_to_anchor=bbox_to_anchor,
                     bbox_transform=ax.transAxes)
    
    cbar = ax.figure.colorbar(lc, cax=cax, orientation=orientation)
    
    if cbar_location == 'top':
        cbar.ax.xaxis.set_ticks_position('top')
        cbar.ax.xaxis.set_label_position('top')
    
    set_axis(cax)
    return cax, cbar

def get_nk_nbands(bfile):
    """Get nk and nbands from band file
    Parameters
    ------------
    bfile : string
        band file name of ALAMODE
    
    Returns
    ----------
    nk, nband : integer
        # of k-points and bands
    """
    nline = sum(1 for line in open(bfile))
    nk = nline - 3
    ifs = open(bfile, "r")
    for i in range(4):
        line = ifs.readline()
    data = line.split()
    nbands = len(data) - 1
    return nk, nbands

def get_symmetry_points_from_file(bfile):
    """Read symmetry points from band file
    
    Returns
    ---------
    label : string
        label for symmetry points
    
    ksym : double
        \|k\| for symmetry points
    
    """
    ifs = open(bfile, "r")
    nline = sum(1 for line in open(bfile))
    lines = []
    lines.append(ifs.readline())
    lines.append(ifs.readline())
    return get_symmetry_points_from_string(lines)

def get_symmetry_points_from_string(lines):
    """Read symmetry points from band file
    
    Returns
    ---------
    label : string
        label for symmetry points
    
    ksym : double
        \|k\| for symmetry points
    
    """
    data1 = lines[0].split()
    data2 = lines[1].split()
    
    label_tmp = []
    kpoints = []
    for i in range(len(data1)-1):
        label_tmp.append(data1[1+i])
        kpoints.append(float(data2[1+i]))
    label = []
    nticks = len(label_tmp)
    for it in range(nticks):
        lab0 = label_tmp[it]
        lab = label_tmp[it]
        if it != 0 and it != nticks-1:
            if abs(kpoints[it] - kpoints[it+1]) < 1e-5:
                lab = "%s|%s" % (lab0, label_tmp[it+1])
            if abs(kpoints[it] - kpoints[it-1]) < 1e-5:
                lab = "%s|%s" % (label_tmp[it-1], lab0)

        ### ver.1
        #if "gamma" in lab.lower() or 'G' in lab:
        #    label.append("G")
        #else:
        #    label.append("%s"%(lab))
        #
        ### ver.2
        lab = lab.upper()
        label.append(lab)
    
    ### adjust
    lab_new = []
    knew = []
    lab_new.append(label[0])
    knew.append(kpoints[0])
    for ii in range(1,len(label)):
        if (abs(kpoints[ii] - kpoints[ii-1]) < 1e-5 and
                label[ii] == label[ii-1]):
            pass
        else:
            lab_new.append(label[ii])
            knew.append(kpoints[ii])
    return lab_new, knew

def get_eigen(filename):
    """ Get kpoints and frequencies """
    
    ### check whether normal band or scph bands
    lines = open(filename, 'r').readlines()

    if "temperature" in lines[2].lower():
        return get_scph_bands(filename)
    else:
        return get_normal_bands(filename)

def get_normal_bands(filename):
    """ Read .bands file """
    dump = np.genfromtxt(filename)
    kpoints = dump[:,0]
    frequencies = dump[:,1:]
    return [kpoints, frequencies]

def get_scph_bands(filename, logfile=None, tol=0.1, verbose=True):
    """ Read .scph_bands file and return array of dictionary for each 
    temperature.
    """
    dump = np.genfromtxt(filename)
    ndat = len(dump[:,0])

    ### get list of temperatures
    temperatures = []
    temperatures.append(dump[0,0])
    for i in range(1, ndat):
        T0 = dump[i-1,0]
        T1 = dump[i,0]
        if abs(T1 - T0) > tol:
            temperatures.append(T1)
    temperatures = np.asarray(temperatures)
    
    ###
    kpoints_list = []
    frequencies_list = []
    for temp in temperatures:
        idx = np.where(abs(dump[:,0] - temp) < tol)[0]
        kpoints_list.append(dump[idx,1])
        frequencies_list.append(dump[idx,2:])
    
    ## Delete data at unavailable temperatures
    from auto_kappa.calculators.scph import get_availabilities
    availabilities = None
    if logfile is None:
        logfile = os.path.dirname(filename) + "/scph.log"
    if os.path.exists(logfile):
        availabilities = get_availabilities(logfile)
        for temp, flag in availabilities.items():
            if flag == False and verbose:
                logger.info(f" Not converged for {temp}K.")
    
    ## Delete unavailable data
    if availabilities is not None:
        idx_na = []
        for it, temp in enumerate(temperatures):
            if availabilities[int(temp)] == False:
                idx_na.append(it)
        temperatures = np.delete(temperatures, idx_na)
        kpoints_list = [np.delete(kpoints, idx_na, axis=0) for kpoints in kpoints_list]
        frequencies_list = [np.delete(frequencies, idx_na, axis=0) for frequencies in frequencies_list]

    return [temperatures, kpoints_list, frequencies_list]
