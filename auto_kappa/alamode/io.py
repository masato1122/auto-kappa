#
# io.py
#
# input and output files
#
# Copyright (c) 2022 Masato Ohnishi
#
# This file is distributed under the terms of the MIT license.
# Please see the file 'LICENCE.txt' in the root directory
# or http://opensource.org/licenses/mit-license.php for information.
#
import os
import sys
import numpy as np
import pandas as pd
from ase.geometry import get_distances

import logging
logger = logging.getLogger(__name__)

def wasfinished_alamode(logfile, tar=None):
    """ Check the ALAMODE job has finished or not with the log file.
    """
    out = {"value": None, "last_line": None}
    try:
        if tar is None:
            lines = open(logfile, 'r').readlines()
        else:
            lines_tmp = tar.extractfile(logfile).readlines()
            lines = [ll.decode('utf-8') for ll in lines_tmp]
        ###
        n = len(lines)
        num_fin = 0
        for line in lines:
            if "Job finished" in line:
                num_fin += 1
        ###
        if num_fin > 1:
            msg  = "\n Warning: ALAMODE was not compiled properly."
            msg += f"\n Please check {logfile} and compile ALAMODE again."
            logger.error(msg)
            sys.exit()
        return num_fin

    except Exception:
        return False

def get_status(logfile, tar=None):
    """ Read and return the status of ALAMODE job
    
    Args
    ------
    
    logfile : string
        ALAMODE log file

    Return
    ---------
    
    status : list with two elements
        out[0] : status ("Finished", "NotYet", or "Error")
        out[1] : comment
    
    """
    import re
    statuses = {0: "Finished", 1: "NotYet", 2: "Error"}
    
    ### possible error messages of ALAMODE
    err_msges = [
            "Force constants could not be determined uniquely",
            "FCSXML files generated by older versions",
            ]
    
    ### read file
    try:
        if tar is None:
            lines = open(logfile, 'r').readlines()
        else:
            lines_tmp = tar.extractfile(logfile).readlines()
            lines = [ll.decode('utf-8') for ll in lines_tmp]
    except Exception:
        return [statuses[1], "Cannot find log file"]
    
    ### error check
    for line in lines:
        for msg in err_msges:
            if re.search(msg, line, flags=re.IGNORECASE):
                return [statuses[2], line]
    
    ### finished or not finished
    if wasfinished_alamode(logfile, tar=tar):
        return [statuses[0], "Job finished"]
    else:
        return [statuses[1], "Not yet finished"]

def write_displacement_info(structure, pristine_structure=None, outdir=None, threshold=1e-5):
    """ Write the displacement information of the structure.
    
    Args
    ------
    
    structure : Structure object
        The structure to write the displacement information.
    
    pristine_structure : Structure object, optional
        The pristine structure for reference. If None, it will not be written.
    
    outdir : str, optional
        The output directory where the file will be saved.
    
    """
    outdir = "./" if outdir is None else outdir
    os.makedirs(outdir, exist_ok=True)
    
    D, D_len = get_distances(
        pristine_structure.get_positions(),
        structure.get_positions(), 
        cell=structure.cell,
        pbc=structure.pbc
    )
    
    ds = np.diag(D_len)
    ids_disp = np.where(ds > threshold)[0]
    if len(ids_disp) == 0:
        return
    
    disp_info = []
    for i in ids_disp:
        disp_info.append({
            "index": i + 1,
            "atom": structure.get_chemical_symbols()[i],
            "disp_mag": ds[i],
            "dx": D[i,i,0],
            "dy": D[i,i,1],
            "dz": D[i,i,2]
        })
    
    outfile = outdir + "/disp_info.csv"
    df = pd.DataFrame(disp_info)
    df.to_csv(outfile, float_format='%.5e', index=False)

