# -*- coding: utf-8 -*-
import os, sys
import os.path
import numpy as np
import warnings
import pandas as pd

import auto_kappa.units as units
from .result import Result
from .analyzer import get_average_at_degenerate_point, get_kmode

class Scattering():
    """
    Hot To Use
    ------------
    >>> scat = Scattering(options.fresult, 
    >>>                 isotope=file_isotope, 
    >>>                 temperature=options.T,
    >>>                 grain_size=size)
    >>>
    >>> scat.set_total_scattering_rate()
    >>> print(scat.kappa)
    >>>
    >>> 
    >>> size = 1000   # nm
    >>> scat.cahnge_grain_size(size)
    >>>
    >>> T = 100.
    >>> scat.change_tempearture(T)
    
    """
    def __init__(self, file_result: None, temperature=300., file_isotope=None,
            grain_size=None, verbosity=0):
        """
        Args
        ----
        file_result : string
            .result file generated by ALAMODE (ph-ph scattering data)
        
        file_isotope : string
            .self_isotope file generated by ALAMODE (isotope scattering)
        
        grain_size : float
            grain size (nm)
        
        Parameters
        -----------
        scattering_rates[keys]
        
        """
        self.verbosity = verbosity

        if file_result is None:
            warnings.warn(" Error: file_result must be given.")
            exit()
        self.result = Result(filename=file_result)
        
        ### properties
        self._averaged_velocities = None
        self._mfp = None
        
        ###
        self.scattering_rates = {}
        
        # -- for ph-ph scattering
        self.scattering_rates['phph'] = None
        self._temperature = temperature
        
        # -- for isotope scattering
        self.file_isotope = file_isotope
        self.scattering_rates['isotope'] = None
        
        # -- for boundary scattering
        self.scattering_rates['boundary'] = None
        self._size  = grain_size
        
        self._total_scattering_rate = None
        """
        .lifetime : ndarray, float, shape=(nk,nb)
            lifetime [ps]
        .kappa : ndarray, float, shape=(3,3)
            thermal conductivity k(xx, xy, xz, ...)
        .kmode : ndarray, float, shape=(nk,nb)
            modal thermal conductivity
        """
        self._lifetime = None
        self._kappa = None
        self._kmode = None
        
        ### ph-ph scattering, T-dependent
        self.set_scattering_rate_phph()
        
        ### T-independent
        if self.file_isotope is not None:
            self.set_scattering_rate_isotope()
        
        ### T-independent
        if self.size is not None:
            self.set_scattering_rate_boundary(size=self.size)
    
    @property
    def kpoints(self):
        return self.result['kpoints']

    @property
    def frequencies(self):
        return self.result['frequencies']
    
    @property
    def averaged_velocities(self):
        
        if self._averaged_velocities is None:
            self.set_averaged_velocities()
        return self._averaged_velocities
    
    def set_averaged_velocities(self):
        
        nk = self.result['nk']
        nb = self.result['nbands']
        vg_ave = np.zeros((nk, nb))
        for ik in range(nk):
            for ib in range(nb):
                vg_multi = self.result['velocities'][ik][ib]
                for vg_each in vg_multi:
                    vg_ave[ik,ib] += np.linalg.norm(vg_each) / len(vg_multi)
        self._averaged_velocities = vg_ave
    
    @property
    def mfp(self):
        if self._mfp is None:
            self.set_mfp()
        return self._mfp
    
    def set_mfp(self):
        ## units: velo (m/s), lifetime (ps), mfp (nm)
        self._mfp = self.averaged_velocities * self.lifetime * 0.001
    
    @property
    def temperature(self):
        return self._temperature
    
    @property
    def size(self):
        return self._size
    
    @property
    def total_scattering_rate(self):
        
        if self._total_scattering_rate is None:
            self.set_total_scattering_rate()
        return self._total_scattering_rate
    
    def set_total_scattering_rate(self):
        
        if (self.file_isotope is not None and
                self.scattering_rates['isotope'] is None):
            self.set_scattering_rate_isotope()

        if (self.size is not None and
                self.scattering_rates['boundary'] is None):
            self.set_scattering_rate_boundary()
        
        ##
        self._total_scattering_rate = np.zeros_like(
                self.scattering_rates['phph'])
        
        msg = " ### Calculate total scattering rate"
        for key in self.scattering_rates:
            if self.scattering_rates[key] is not None:
                msg += "  * %s\n" % key
                self._total_scattering_rate += self.scattering_rates[key]
        msg += "\n"
        if self.verbosity > 0:
            print(msg)
        
        self.set_lifetime()
        self.set_kmode()
    
    @property
    def lifetime(self):
        """ Lifetime with the unit of pico second (ps) """
        if self._lifetime is None:
            self.set_lifetime()
        return self._lifetime
    
    def set_lifetime(self):
        """calculate lifetime and thermal conductivity
        """
        lifetime = convert_scatrate2lifetime(
                self.total_scattering_rate)  # ps
        self._lifetime = get_average_at_degenerate_point(
                self.result['frequencies'], lifetime)
     
    @property
    def kmode(self):
        if self._kmode is None:
            self.set_kmode()
        return self._kmode

    @property
    def kappa(self):
        if self._kappa is None:
            self.set_kmode()
        return self._kappa
    
    def set_kmode(self):
        """calculate model thermal conductivity
        """
        self._kappa, self._kmode = get_kmode(
                self.result['volume'],
                self.temperature,
                self.result['frequencies'],
                self.result['multiplicity'],
                self.result['velocities'],
                self.lifetime)
    
    def get_cumulative_kappa(self, temperature=300., grain_size=None,
            wrt='frequency', nbins=200, xscale='linear'):
        """ Return cumulative kappa w.r.t the given property, frequency or MFP.

        Args
        -------
        wft : string
            "frequency" or "mfp"
        
        Return
        ---------
        df : DataFrame
        df['xdat'] : array, shape=(nk*nb)
            values of the given property, frequency or MFP
        df['kspec'] : array,
            cumulative kappa
        df['kcumu'] : array,
            spectral kappa
        """
        ## set grain size
        if self.size != grain_size:
            self._size = grain_size
            self.change_grain_size(grain_size)
        
        ## set temperature
        if abs(self.temperature - temperature) > 0.1:
                    self.change_temperature(temperature)
        
        ### get non-directional cumulative kappa
        nk = self.result['nk']
        nbands = self.result['nbands']
        frequencies = self.result['frequencies']
        
        if 'freq' in wrt.lower():
            xorig = frequencies.reshape(nk*nbands)  ## 1/cm
        else:
            xorig = self.mfp.reshape(nk*nbands)     ## nm
            
        kmodes = np.zeros_like(frequencies)
        for ik in range(nk):
            for ib in range(nbands):
                kmodes[ik,ib] = np.average(np.diagonal(self.kmode[ik,ib]))
        
        yorig = kmodes.reshape(nk*nbands)
        
        ### (frequency or MFP) vs cumulative kappa
        if xscale == 'log':
            
            idx = np.where(xorig>1e-5)[0]
            xmod = xorig[idx]
            ymod = yorig[idx]
            
            isort = np.argsort(xmod)
            xmin = xmod[isort[5]]
            if wrt == 'mfp':
                xmin = max(5., np.min(xmod))
            xmin_log = np.log10(xmin)
            xmax_log = np.log10(np.max(xmod))
            xbins = np.logspace(xmin_log, xmax_log, nbins+1)
            
        else:
            isort = np.argsort(xorig)
            xmin = xorig[isort[5]]
            xmax = np.max(xorig)
            xbins = np.linspace(xmin, xmax, nbins+1)
         
        xbins[0] = np.min(xorig) - 1e-3
        ybins = np.zeros_like(xbins)
        cats = pd.cut(xorig, xbins)
        idx = cats.codes
        for i, x in enumerate(xorig):
            ybins[idx[i]] += yorig[i]
        
        ###
        df = pd.DataFrame()
        df['xdat'] = xbins
        df['kcumu'] = ybins.cumsum()
        df['kspec'] = ybins
        return df
    
    def get_kmin_cahill(self, bvec, temperature):
        """
        Args
        -------
        bvec : shape=(3,3), reciprocal vectors
        
        Return
        ----------
        kappa : shape=()
        kmode : shape=()

        Example
        -----------
        >>> 
        >>> bvec = atoms.cell.get_reciprocal()
        >>> kmin, kmode = scat.get_kmin_cahill(bvec, T)
        >>> 
        """
        from .analyzer import get_heat_capacity
        
        nk = len(self.result['frequencies'])
        nb = len(self.result['frequencies'][0])
        
        ## wavevectors: [1/A], shape=(nk,3)
        wavevectors = np.dot(self.result['kpoints'], bvec)
        
        ## norm of wavevectors
        wave_norm = np.zeros(nk)
        for ik in range(nk):
            wave_norm[ik] = np.linalg.norm(wavevectors[ik])   # 1/A
        
        ## wavelength: shape=(nk)
        wavelengths = np.zeros(nk)
        idx1 = np.where(abs(wave_norm) >= 1e-7)
        wavelengths[idx1] = 0.1 / wave_norm[idx1]   # nm
        
        ## with minimum MFP
        kmode = np.zeros((nk,nb,3))
        multiplicity = self.result['multiplicity']
        for ik in range(nk):
            wl = wavelengths[ik] * 1e-9    # m
            multi = multiplicity[ik]
            for ib in range(nb):
                vg = np.zeros(3)
                for im in range(multi):
                    vg += abs(self.result['velocities'][ik,ib,im] / multi)
                ##
                if self.result['frequencies'][ik,ib] < 0.:
                    kmode[ik,ib] = np.zeros(3)
                else:
                    Cph = get_heat_capacity(
                            self.result['frequencies'][ik,ib], 
                            temperature)  # J/K
                    
                    ## ver.1
                    kmode[ik,ib] = vg * Cph * wl*0.5 * multi    # W*m^2/K
                    ## ver.2
                    #mfp = vg * self.lifetime[ik,ib] * 1e-12
                    #kmode[ik,ib] = vg * Cph * mfp * multi
                    # W*m^2/K
        
        ## modal kappa [W/m/K]
        volume = self.result['volume']
        kmode *= (1./volume/(units.BohrToM**3)/ float(np.sum(multiplicity)))
        
        ## total kappa
        kappa = np.zeros(3)
        for j in range(3):
            kappa[j] = np.sum(kmode[:,:,j])
        
        return kappa, kmode
    
    #def get_squared_velocities(self):
    #    """
    #    Return
    #    -----------
    #    v2s : shape=(nk,nb,3,3), |vg|^2
    #    """
    #    ## get v2tensor
    #    nk = len(self.result['frequencies'])
    #    nb = len(self.result['frequencies'][0])
    #    
    #    v2s = np.zeros((nk,nb,3,3))
    #    for ik in range(nk):
    #        for ib in range(nb):
    #            v2tensor = np.zeros((3,3))
    #            for im in range(self.result['multiplicity'][ik]):
    #                #        vaves += 
    #                v2tensor += (
    #                        self.result['velocities'][ik][ib][im] *
    #                        self.result['velocities'][ik][ib][im].reshape(3,1)
    #                        )
    #            ##
    #            v2s[ik,ib,:,:] = v2tensor
    #    return v2s
    
    def change_temperature(self, temperature):
        """set temperature and update properties
        """
        idx = np.argmin(abs(self.result['temperatures'] - temperature))
        
        self._temperature = self.result['temperatures'][idx]
        
        if abs(self.temperature - temperature) > 0.1:
            print("")
            print(" NOTE: target temperature is adjusted from %.1f K to "
                    "%.1f K." % (temperature, self.temperature))
            print("")
        
        self.set_scattering_rate_phph()
        self.set_total_scattering_rate()
        self.set_kmode()
    
    def change_grain_size(self, size):
        self._size = size
        self.set_scattering_rate_boundary()
        self.set_total_scattering_rate()
        self.set_kmode()

    def set_scattering_rate_phph(self):
        """
        Return
        ------
        *** : ndarray, float, shape=(nk,nb)
            scattering rate due to ph-ph scattering [1/ps]
        """
        itarget = np.argmin(abs(self.result['temperatures'] - self.temperature))
        
        ## 1/ps
        self.scattering_rates['phph'] = convert_gamma2scatrate(
                self.result['gammas'][itarget,:,:])
        
    def set_scattering_rate_isotope(self):
        from .isotope import Isotope
        if os.path.exists(self.file_isotope) == False:
            warnings.warn(" %s does not exist." % filename)
        else:
            iso = Isotope(filename=self.file_isotope)
            ## 1/ps
            self.scattering_rates['isotope'] = convert_gamma2scatrate(iso.gammas)
    
    def set_scattering_rate_boundary(self, size=None):
        """ Scattering rates due to grain boundaries are calculated with
        2*|v|/L, where v and L are group velocities and grain size. 
        """
        if size is None:
            size = self.size
        else:
            self._size = size
        
        if self.size is None or self.size <= 0.:
            self.scattering_rates['boundary'] = None
            return None
         
        nk = self.result['nk']
        nbands = self.result['nbands']
        
        ## rate [1/ps]
        self.scattering_rates['boundary'] = (
                1e-3 * 2. * self.averaged_velocities / size
                )
    
###
def convert_gamma2scatrate(gammas):
    """
    Unit of gamma : Kayser [1/cm]
    Unit of scattering rate : [1/ps]
    """
    return 2. * gammas * units.AlmCmToHz * 1e-12

def convert_scatrate2lifetime(rscat, epsilon=1e-10):
    """
    Unit of scattering rate : [1/ps]
    Unit of lifetime : [ps]
    """
    rscat_tmp = np.where(rscat<epsilon, 1.0, rscat)
    lifetime = np.where(rscat<epsilon, 0.0, 1./rscat_tmp)
    return lifetime

#def dump_scattering_rate(filename, freqs, rscat_tot, temp,
#        rscat_phph=None, rscat_iso=None, rscat_bdy=None,
#        size=None, model=None, gamma=None,
#        rscat_ts=None):
#    """Output scattering rate
#    freqs, rscat_**: ndarray, float, shape=(nk,nb)
#        frequencies[1/cm] and scattering rate[1/ps]
#    rscat_iso, rscat_bdy, rscat_ts : ndarray, float, shape=(nk,nb)
#        scattering rate [1/ps] due to isotope, boundary, tunneling states,
#        respectively
#    size : float
#        grain size [nm]
#    model : string (n... or h...)
#    gamma : float
#        gamma parameter of Hori model
#    """
#    ofs = open(filename, "w")
#    # ---- beggining
#    ofs.write("# Scattering rate [1/ps] including the following effects.\n")
#    ofs.write("# Tempearture : {:.2f} K\n".format(temp))
#    ofs.write("# - Phonon-phonon scattering\n")
#    if size:
#        ofs.write("# - Boundary scattering due to {:.2f} nm "
#                "grain\n".format(size))
#        if model.lower()[0] == "n":
#            ofs.write("#   calculated by 2*|v|/L model\n")
#        if model.lower()[0] == "h":
#            ofs.write("#   calculated by SL+nanocrystal model ")
#            ofs.write("with gamma = {:f}\n".format(gamma))
#    else:
#        ofs.write("#\n")
#    if rscat_iso is not None:
#        ofs.write("# - Isotope scattering\n")
#    else:
#        ofs.write("#\n")
#    ofs.write("#ik ib Frequency[1/cm]  total")
#    if rscat_phph is not None:
#        ofs.write("      ph-ph")
#    if rscat_iso is not None:
#        ofs.write("         isotope")
#    if rscat_bdy is not None:
#        ofs.write("       boundary({:s})".format(model))
#    if rscat_ts is not None:
#        ofs.write("      tunnling")
#    ofs.write("\n")
#    # --- dump data
#    for ik in range(len(rscat_tot)):
#        for ib in range(len(rscat_tot[ik])):
#            ofs.write("{:2d} {:2d} ".format(ik, ib))
#            ofs.write("{:12.5f}".format(freqs[ik,ib]))
#            ofs.write(" {:13.5e}".format(rscat_tot[ik,ib]))
#            if rscat_phph is not None:
#                ofs.write(" {:13.5e}".format(rscat_phph[ik,ib]))
#            if rscat_iso is not None:
#                ofs.write(" {:13.5e}".format(rscat_iso[ik,ib]))
#            if rscat_bdy is not None:
#                ofs.write(" {:13.5e}".format(rscat_bdy[ik,ib]))
#            if rscat_ts is not None:
#                ofs.write(" {:13.5e}".format(rscat_ts[ik,ib]))
#            ofs.write("\n")
#    ofs.close()
#    print(" Output", filename)


