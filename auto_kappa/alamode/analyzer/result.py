#
# result.py
#
# This script mainly contains Result class which is used to anlayze .result file
# generated by Alamode.
#
# Copyright (c) 2022 Masato Ohnishi
#
# This file is distributed under the terms of the MIT license.
# Please see the file 'LICENCE.txt' in the root directory
# or http://opensource.org/licenses/mit-license.php for information.
#
import sys
#import warnings
import numpy as np

from auto_kappa.alamode.analyzer.analyzer import get_kmode

import logging
logger = logging.getLogger(__name__)

class Result():
    def __init__(self, filename=None):
        """ Read .result file generated by Alamode
        Args
        -----
        filename : string
            *.result file name
        
        Parameters
        ------------
        frequencies : ndarray, float, shape=(nkpoints,nbands)
            eigenvalues
        general : General() class
            information in "#General" section
        
        multiplicity : array, int, shape=(nk)
        velocities : ndarry, float, shape=(nk,nband,multiplicity[ik],3)
        gammas : array, float, shape=(ntemps,nk,nb)
        
        kmode : ndarray, float, shape=(ntemps,nkpoints,nbands,mmax,3,3)
            thermal conductivity of each mode
        lmode : ndarray, float, shape=(ntemps,nkpoints,nbands,mmax,3)
            MFP of each mode
        
        """
        self._values = None
        self.filename = filename
        
        self._lifetime = None
        self._kmode = None
        self._lmode = None

        if self.filename is not None:
            self.set_result()
    
    def __getitem__(self, key):
        
        for k1 in self._values:
            if k1 == key:
                return self._values[k1]
            for k2 in self._values[k1]:
                if k2 == key:
                    return self._values[k1][k2]
        
        msg = "\n Warning: %s cannot be found.\n" % key
        logger.warning(msg)
        return None
    
    def set_result(self):
        """
        Read self.filename and set class
        """
        if self.filename is None:
            logger.error(" Error: filename (*.result file) must be given.")
            sys.exit()
        
        self._values = read_result_file(self.filename)
        
    def get_free_energy(self, temperatures):
        """Calcualte free enrgy
        Args
        -----
        temmperatures : array, float, shape=(nt)
            list of temperatures
        """
        return _get_free_energy(
                self.natoms,
                self.volume,
                self.temperatures,
                self.multiplicity, 
                self.frequencies)
    
    #def output_result(self, outfile="new.result"):
    #    
    #    gen = self.general
    #    res = self.relax
    #    ofs = open(outfile, "w")
    #    ofs.write("## General information \n")
    #
    #    ofs.write("#SYSTEM \n")
    #    ofs.write("%d %d \n" % (gen.natoms, gen.nelements))
    #    ofs.write("%.7f \n" % gen.volume)
    #    ofs.write("#END SYTEM \n")
    #
    #    ofs.write("#KPOINT \n" % ())
    #    for j in range(3):
    #        ofs.write("%d " % (gen.kmesh[j]))
    #    ofs.write("\n")
    #    ofs.write("%d \n" % (gen.nkpoints))
    #    for ik in range(gen.nkpoints):
    #        ofs.write("     %d: " % (ik+1))
    #        for j in range(3):
    #            ofs.write("%13.7e " % (gen.kpoints[ik,j]))
    #        ofs.write("%13.7e \n" % (gen.kabs[ik]))
    #    ofs.write("#END KPOINT \n")
    #    
    #    ofs.write("#CLASSICAL \n")
    #    ofs.write("%d\n" % gen.classical)
    #    ofs.write("#END CLASSICAL\n")
    #
    #    ofs.write("#FCSXML \n")
    #    ofs.write("%s \n" % (gen.fcsxml))
    #    ofs.write("#END FCSXML \n")
    #
    #    ofs.write("#SMEARING \n")
    #    ofs.write("%d \n" % (gen.ismear))
    #    ofs.write("%d \n" % (gen.smearing))
    #    ofs.write("#END SMEARING \n")
    #
    #    ofs.write("#TEMPERATURE\n")
    #    for T in gen.temperatures:
    #        ofs.write("%.1f " % (T))
    #    ofs.write(" \n")
    #    ofs.write("#END TEMPERATURE \n")
    #
    #    ofs.write("##END General information \n")
    #
    #    ofs.write("##Phonon Frequency \n")
    #    ofs.write("#K-point (irreducible), Branch, Omega (cm^-1) \n")
    #    for ik in range(self.nkpoints):
    #        for ib in range(self.nbands):
    #            ofs.write("  %3d  %3d " % (ik+1, ib+1))
    #            ofs.write(" %15.8e\n" % (self.frequencies[ik,ib]))
    #    ofs.write("##END Phonon Frequency \n")
    #    ofs.write("\n")
    #
    #    ofs.write("##Phonon Relaxation Time \n")
    #    for ik in range(res.nkpoints):
    #        for ib in range(res.nbands):
    #            ofs.write("#GAMMA_EACH \n")
    #            ofs.write("%d %d \n" % (ik+1, ib+1))
    #            ofs.write("%d \n" % (res.multiplicity[ik]))
    #            for im in range(res.multiplicity[ik]):
    #                for j in range(3):
    #                    ofs.write("%15.5e " % (res.velocities[ik,ib,im,j]))
    #                ofs.write(" \n")
    #            for it in range(res.ntemps):
    #                ofs.write("%15.8f \n" % (res.gammas[it,ik,ib]))
    #            ofs.write("#END GAMMA_EACH \n")
    #    ofs.write("##End Phonon Relaxation Time \n")
    
    #@property
    #def natoms(self):
    #    return self._values['system']['natoms']
    #
    #@property
    #def nkpoints(self):
    #    return self._values['kpoint']['nk']
    #
    #@property
    #def nbands(self):
    #    return self._values['system']['natoms'] * 3
    #
    #@property
    #def nelements(self):
    #    return self._values['system']['nelements']
    #
    #@property
    #def frequencies(self):
    #    return self._values['frequency']['frequencies']
    #
    #@property
    #def multiplicity(self):
    #    return self._values['relaxation_time']['multiplicity']
    #
    #@property
    #def gammas(self):
    #    return self._values['relaxation_time']['gammas']
    #
    #@property
    #def velocities(self):
    #    return self._values['relaxation_time']['velocities']
    #
    #@property
    #def temperatures(self):
    #    return self._values['temperature']['temperatures']
    #
    #@property
    #def volume(self):
    #    return self.values['system']['volume']
    #
    #@property
    #def lifetime(self):
    #    if self._lifetime is None:
    #        self._lifetime = get_lifetime()


def _get_line_number(lines, word):
    for il, line in enumerate(lines):
        if word in line:
            return il
    return None

def read_result_file(filename):
    
    params = {}
    params['system'] = read_system(filename)
    params['kpoint'] = read_kpoint(filename)
    params['classical'] = read_classical(filename)
    params['fcsxml'] = read_fcsxml(filename)
    params['smearing'] = read_smearing(filename)
    params['temperature'] = read_temperature(filename)
    params['frequency'] = read_frequency(filename)
    
    ### nbands
    params['system']['nbands'] = 3 * params['system']['natoms']
    
    ### tempeartures
    ts = []
    ts.append(params['temperature']['tmin'])
    flag = True
    while flag:
        temp = ts[-1] + params['temperature']['dt']
        if temp <= params['temperature']['tmax'] + 1e-5:
            ts.append(temp)
        else:
            flag = False
            break
    params['temperature']['temperatures'] = np.asarray(ts)
    
    ###
    params['relaxation_time'] = read_relaxation_time(
            filename, 
            len(params['temperature']['temperatures']),
            params['kpoint']['nk'], 
            3 * params['system']['natoms']
            )
    return params

def read_system(filename):
    """ Return number of atoms and elements and volume in SYSTEM part
    """
    lines = open(filename, 'r').readlines()
    iline0 = _get_line_number(lines, "#SYSTEM")
    if iline0 is None:
        return None

    ### nat and nel
    data = lines[iline0+1].split()
    nat = int(data[0])
    nel = int(data[1])

    ### volume
    data = lines[iline0+2].split()
    volume = float(data[0])
    return {'natoms': nat, 'nelements': nel, 'volume': volume}

def read_kpoint(filename):
    """Get number of kpoints
    Args
    ----
    fn : string
        .result file name

    Return
    --------
    kmesh : array, int, shape=(3)
        kmesh
    nk : integer
        number of irreducible kpoints
    kpoints : ndarray, float, shape=(nk,3)
        k points
    weights : array, float, shape=(nk)
        weights
    """
    lines = open(filename, 'r').readlines()
    iline0 = _get_line_number(lines, "#KPOINT")
    if iline0 is None:
        return None
    
    ### kmesh
    kmesh = np.zeros(3)
    data = lines[iline0+1].split()
    for j in range(3):
        kmesh[j] = int(data[j])
    
    ### nkpoints
    nk = int(lines[iline0+2].split()[0])
    
    ###  kpoints
    kpoints = np.zeros((nk,3))
    weights = np.zeros(nk)
    for i in range(nk):
        data = lines[iline0+3+i].split()
        for j in range(3):
            kpoints[i,j] = float(data[j+1])
        weights[i] = float(data[4])
    
    return {'kmesh': kmesh, 'nk': nk, 'kpoints': kpoints, 'weights': weights}

def read_classical(filename):
    """ Return classical """
    lines = open(filename, 'r').readlines()
    iline0 = _get_line_number(lines, "#CLASSICAL")
    if iline0 is None:
        return iline0
    cla = int(lines[iline0+1])
    return {'classical': cla}

def read_fcsxml(filename):
    """ Return fcsxml """
    lines = open(filename, 'r').readlines()
    iline0 = _get_line_number(lines, "#FCSXML")
    if iline0 is None:
        return iline0
    cla = lines[iline0+1].split()[0]
    return {'fcsxml': cla}

def read_smearing(filename):
    """ Return smearing """
    lines = open(filename, 'r').readlines()
    iline0 = _get_line_number(lines, "#SMEARING")
    if iline0 is None:
        return iline0
    ismear = int(lines[iline0+1])
    epsilon = int(lines[iline0+2])
    return {'ismear': ismear, 'epsilon': epsilon}

def read_temperature(filename):
    """ Return temperature """
    lines = open(filename, 'r').readlines()
    iline0 = _get_line_number(lines, "#TEMPERATURE")
    if iline0 is None:
        return iline0
    data = lines[iline0+1].split()
    t0 = float(data[0])
    t1 = float(data[1])
    dt = float(data[2])
    return {'tmin': t0, 'tmax': t1, 'dt': dt}

def read_frequency(filename):
    """ Read and return frequencies in rfile, which is \*.result file.
    
    Args
    ----------
    filename : string
        \*.result file name

    Return
    -------
    nkpoints, nbands : integer
        # of kpoints and bands
    
    frequencies : ndarray, float, shape=(nkpoints, nbands)
        eigenvalues
    """
    lines = open(filename, 'r').readlines()
    iline0 = _get_line_number(lines, "#K-point")
    nlines = len(lines)

    kpoints = []
    branches = []
    frequencies = []
    
    for il in range(iline0+1, nlines):
        
        line = lines[il]
        data = line.split()

        if "#" in line:
            break
        
        kpoints.append(int(data[0]))
        branches.append(int(data[1]))
        frequencies.append(float(data[2]))
    
    kpoints = np.asarray(kpoints)
    branches = np.asarray(branches)
    
    nk = int(np.max(kpoints))
    nbands = int(np.max(branches))
    frequencies = np.asarray(frequencies).reshape(nk, nbands)
    return {'ikpoints': kpoints, 'branches': branches, 'frequencies': frequencies}

def read_relaxation_time(filename, ntemps, nk, nbands):
    """Get relaxation time
    Args
    -----
    filename : string
        .result file name
    ntemps, nk, nbands : integer
        # of temperatures, kpoints, and bands

    Returns
    -------
    multiplicity : array, int, shape=(nk)
        multiplicity
    velocities : ndarray, float, shape=(nk, nbands, multiplicity, 3)
        velocities
    gammas : ndarray, float, shape=(ntemps,nk,nbands)
        gammas due to ph-ph scattering
    """
    ##
    lines = open(filename, 'r').readlines()
    iline0 = _get_line_number(lines, "##Phonon Relaxation Time")
    
    # --- prepare arrays
    multiplicity = np.zeros(nk, dtype=int)
    velocities = []
    gammas = np.zeros(((ntemps, nk, nbands)))
    
    il = iline0
    sword = "#GAMMA_EACH"
    for ik in range(nk):
        velocities.append([])
        
        for ib in range(nbands):
            
            velocities[-1].append([])
            
            ### #GAMMA_EACH
            il += 1
            line = lines[il]
            if sword not in line:
                data = line.split()
                logger.error("\n Error: %s does not include %s" % (data[0], sword))
                sys.exit()
            
            ### ik, ib
            il += 1
            data = lines[il].split()
            ik_check = int(data[0])
            ib_check = int(data[1])
            if ik != ik_check-1 or ib != ib_check-1:
                msg = "\n Error in %s" % filename
                msg += "\n ik(%d!=%d) or ib(%d!=%d)" % (ik, ik_check-1, ib, ib_check-1)
                msg += "\n " + lines[il]
                logger.error(msg)
                return None
            
            ### multiplicity
            il += 1
            data = lines[il].split()
            multi = int(data[0])
            multiplicity[ik] = multi
            
            ### group velocities
            velocities[-1][-1] = np.zeros((multi, 3))
            for im in range(multi):
                il += 1
                data = lines[il].split()
                for j in range(3):
                    velocities[ik][ib][im,j] = float(data[j])
            ### (multi)- : gamma
            for it in range(ntemps):
                il += 1
                data = lines[il].split()
                gammas[it,ik,ib] = float(data[0])
            
            ### #END GAMMA_EACH
            il += 1
            if "#END GAMMA_EACH" not in lines[il]:
                logger.error(" Error while reading %s" % filename)
                sys.exit()
    
    return {'multiplicity': multiplicity, 
            'velocities': velocities, 
            'gammas': gammas}



def _get_free_energy(natoms, volume, temps, multi, freqs):
    """Calculate free energy with quasi-harmonic approximation (QHA)
    Args
    -----
    natoms : integer
        number of atoms in a primitive cell
    volume : float, unit=[Bohr^3]
        volume of a primitive cell
    temps : array, float, shape=(nt), unit=[K]
        list of temperatures
    multi : array, int, shpae=(nk)
        multiplicity
    freqs : ndarrya, float, shape=(nk,nb), unit=[cm^-1]
        frequencies

    Return
    ------
    efree : array, float, shape=(nt), unit=[J/mol]
        T-dependent free energy
    """
    energies = freqs * units.CmToJ     # [J]
    kbTs = temps * units.KToJ          # [J]
    # -- T-independent term
    efree0 = 0.5 * np.sum(np.sum(energies, axis=1) * multi)      # [J]
    # -- T-dependent term
    efreeT = np.zeros_like(temps)
    for it, kbT in enumerate(kbTs):
        efreeT[it] = (kbT * np.sum(
            np.sum(np.log(1. - np.exp(-energies/kbT)), axis=1) * 
            multi))
    efree_tot = efree0 + efreeT
    efree_tot *= units.Nav / float(natoms) / float(np.sum(multi))
    return efree_tot


#def _get_kpoint(ifs, nline, line_fin):
#    fdump = []
#    ik = -1
#    for il in range(nline):
#        line = ifs.readline()
#        data = line.split()
#        if len(data) == None:
#            continue
#        if line.find(line_fin) != -1:
#            break
#        if int(data[0]) != ik+1:
#            fdump.append([])
#            ik += 1
#        fdump[ik].append(float(data[2]))
#
#    nkpoints = len(fdump)
#    nbands = len(fdump[0])
#    frequencies = np.zeros((nkpoints, nbands))
#    for ik in range(nkpoints):
#        for ib in range(nbands):
#            frequencies[ik,ib] = fdump[ik][ib]
#
#    return nkpoints, nbands, frequencies


