#
# errors.py
#
# Treat unexpected errors for ALAMODE
#
# Copyright (c) 2024 Masato Ohnishi
#
# This file is distributed under the terms of the MIT license.
# Please see the file 'LICENCE.txt' in the root directory
# or http://opensource.org/licenses/mit-license.php for information.
#
import os
import sys
import shutil
import glob
import logging
import tarfile
import numpy as np

from auto_kappa import output_directories
from auto_kappa.alamode.log_parser import get_version

logger = logging.getLogger(__name__)

err_messages = {
        "kpoint": "KPOINT information is not consistent",
        "version": "FCSXML files generated by older versions",
        "numfcs": "Force constants could not be determined uniquely because"
        }

def _print_error_message(filename, error_msg):
    """ """
    msg = "\n Error found in %s:\n" % filename
    msg += error_msg
    logger.error(msg)

def check_unexpected_errors(logfile, dir_base=None):
    """ 
    The initial directory is the same directory where ``logfile`` is located.
    
    Return
    =========
    int : 
        0 if no error was found.
        1 error was found
    """
    if os.path.exists(logfile) == False:
        return None
    
    ### check each line
    ### If flag > 0, the job will be stopped.
    flag = 0
    lines = open(logfile, 'r').readlines()
    for line in lines:
        
        ### Error in .result file
        if err_messages["kpoint"].lower() in line.lower():
            
            _print_error_message(logfile, line)
            
            if logfile == "kappa.log":
                ### The job can be continued after .result file is removed.
                _error_in_result_file()
                flag += 0
            else:
                msg = "\n Error in %s" % logfile
                msg += "\n The error is not supported yet."
                logger.error(msg)
                sys.exit()
        
        ### Version error
        if err_messages["version"].lower() in line.lower():
            _print_error_message(logfile, line)
            flag += _solve_version_incompatibility(dir_base, logfile)
        
        ### FCs could not be deteremined uniquely
        if err_messages["numfcs"].lower() in line.lower():
            _print_error_message(logfile, line)
            
            msg = "\n Error: Rank deficient"
            msg += "\n Stop the calculation."
            logger.error(msg)
            sys.exit()
    
    ### Stop the calculation
    if flag != 0:
        msg = "\n Stop the calculation because of the error."
        msg += "\n Please rerun the calculation."
        logger.error(msg)
        sys.exit()
    
    return flag

def _solve_version_incompatibility(dir_top, logfile):
    """ Solve the problem because of the version incompability of ALAMODE """
    
    if logfile in ["cv.log", "lasso.log", "fc3.log"]:
        
        _compress_harmonic_fcs(dir_top)
        _compress_cubic_fcs(dir_top)
        flag = 11
    
    else:
        msg = "\n Error in %s" % logfile
        msg += "\n The error is not supported yet."
        logger.error(msg)
        sys.exit()

    return flag

def is_fc_given(logfile, order=None):
    """ """
    name = "FC%dXML =" % (order+1)
    lines = open(logfile, 'r').readlines()
    
    flag = False
    for line in lines:
        if name in line:
            flag = True
            break
    ##
    if flag:
        if len(line.split()) > 2:
            return True
        else: 
            return False
    else:
        return False

def _move_and_compress_files(prefix, files_disp):
    """ Make ``prefix``-*.tar.gz including ``files_disp``
    
    Args
    --------
    prefix : string
        ``prefix``-*.tar.gz file will be created

    files_disp : list of string
        list of file names to be displaced
    """
    dir_new = _determine_new_dirname(prefix, "tar.gz")
    tar_new = dir_new + ".tar.gz"
    with tarfile.open(tar_new, "w:gz") as tar:
        for ff in files_disp:
            if os.path.exists(ff):
                tar.add(ff)
                logger.info(" %s => %s" % (ff, tar_new))
        tar.close()
    
    ### delete original files
    for ff in files_disp:
        if os.path.isfile(ff):
            os.remove(ff)
        elif os.path.isdir(ff):
            shutil.rmtree(ff)
        logger.info(" Remove %s" % ff)
    
    return 0

def _determine_new_dirname(prefix, suffix):
    dirs_old = glob.glob(prefix + "-*." + suffix)
    try:
        nums = [int(dir_old.replace(prefix+"-", "").replace("."+suffix, "")) for dir_old in dirs_old]
        idx_new = np.max(np.asarray(nums)) + 1
    except Exception:
        idx_new = 1
    dir_new = prefix + "-" + str(idx_new)
    return dir_new

def _compress_harmonic_fcs(dir_top):
    """ """
    ### move directories
    dir_init = os.getcwd()
    os.chdir(dir_top)
    
    files_disp = []

    ### directories to be compressed 
    for key in output_directories["harm"]:
        dir_name = output_directories["harm"][key]
        if key in ["bandos", "evec", "suggest"]:
            files_disp.append(output_directories["harm"][key])
    
    ### FC2 files
    dir_force = output_directories["harm"]["force"]
    for fns in (
            glob.glob(dir_force + "/fc2.*"),
            glob.glob(dir_force + "/*.fcs"),
            glob.glob(dir_force + "/*.xml")):
        for ff in fns:
            files_disp.append(ff)
    
    ### compress and delete files and directories
    prefix = "harm"
    _move_and_compress_files(prefix, files_disp)
    
    ### move back to the original directory
    os.chdir(dir_init)
    
    return 0

def _compress_cubic_fcs(dir_base):
    """ """
    ### move directories
    dir_init = os.getcwd()
    os.chdir(dir_base)
    
    files_disp = []
    
    for key in output_directories["cube"]:
        
        dir_name = output_directories["cube"][key]
        
        if key in ["suggest", "lasso"]:
            files_disp.append(dir_name)
        
        elif key in ["kappa_fd", "kappa_lasso"]:
            for ff in glob.glob(dir_name + "*"):
                files_disp.append(ff)
        
        elif key == "force_fd":
            for fns in (
                    glob.glob(dir_name + "/fc3.*"),
                    glob.glob(dir_name + "/*.fcs"),
                    glob.glob(dir_name + "/*.xml")):
                for ff in fns:
                    files_disp.append(ff)
    
    ### compress and delete files and directories
    prefix = "cube"
    _move_and_compress_files(prefix, files_disp)
        
    os.chdir(dir_init)
    return 0

def _error_in_result_file():
    """ Error in .result file for the previous calculation """
    
    prefix = os.getcwd().split("/")[-1]
    
    files_disp = []
    for ff in glob.glob("*"):
        if ff in ["BORNINFO", "kappa.in"] or prefix in ff:
            continue
        else:
            files_disp.append(ff)
    ###
    _move_and_compress_files(prefix, files_disp)
    return 0

def found_rank_deficient(logfile):
    """ Check the previous force constant calculation
    If the following line is found in the logfile, return True.
    
    If "WARNING : Rank deficient
    """
    lines = open(logfile, 'r').readlines()
    for line in lines:
        if "Rank deficient" in line:
            return True
    return False
